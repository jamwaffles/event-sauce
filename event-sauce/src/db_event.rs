//! Database storage for [`Event`]s

use crate::{event::Event, EventData};
use chrono::{DateTime, Utc};
use postgres::Row;
use std::convert::TryFrom;
use uuid::Uuid;

/// Internal event definition
///
/// This is similar to an [`Event`], however has a few database-specific changes made to it:
///
/// * The `sequence_number` field is added to align the struct shape to the table structure. This is
///   an autogenerated value added by Postgres and **should not be set in user code**.
/// * The `data` field is now a generic [`serde_json::Value`] instead of a specialised,
///   application-specific struct. This maps to the Postgres `json` field type.
#[derive(Debug, Clone)]
pub struct DBEvent {
    /// Event ID
    pub id: Uuid,
    /// Sequence number
    ///
    /// This field is autogenerated by the database and should not be set in user code
    pub sequence_number: Option<i32>,

    /// Event type
    ///
    /// This field provides information about how this event was originated.
    pub event_type: String,

    /// Entity Type
    ///
    /// This field must contain the name of the table the event relates to
    pub entity_type: String,

    /// The ID of the entity (user, organisation, etc) that this event aggregates into
    pub entity_id: Uuid,

    /// Event data
    ///
    /// This is a generic [`serde_json::Value`] representation of the event payload. It is
    /// deserialised into a more useful form using `Event::try_from()`. If the event has been
    /// purged, this will be `None` for security/compliance reasons - the data must be deleted from
    /// both the event log and the aggregate tables. Check the `purged_at` or `purger_id` fields to
    /// check the purge status.
    pub data: Option<serde_json::Value>,

    /// The ID of the creator of this event
    pub session_id: Option<Uuid>,

    /// The time at which this event was created
    pub created_at: DateTime<Utc>,

    /// Purger subject ID
    ///
    /// Will be `None` if event is not purged
    pub purger_id: Option<Uuid>,

    /// The time at which this event was purged, if any
    pub purged_at: Option<DateTime<Utc>>,
}

impl<S: EventData> TryFrom<Event<S>> for DBEvent {
    type Error = serde_json::Error;

    /// Attempt to convert an [`Event`] into a `DBEvent`
    ///
    /// This serialises the `data` field into a [`serde_json::Value`]. All other fields are left as
    /// is.
    fn try_from(other: Event<S>) -> Result<DBEvent, Self::Error> {
        let data: Option<serde_json::Value> = if let Some(d) = other.data {
            Some(serde_json::to_value(d)?)
        } else {
            None
        };

        Ok(DBEvent {
            id: other.id,
            sequence_number: None,
            event_type: other.event_type,
            entity_type: other.entity_type,
            entity_id: other.entity_id,
            session_id: other.session_id,
            purger_id: other.purger_id,
            created_at: other.created_at,
            purged_at: other.purged_at,
            data,
        })
    }
}

impl TryFrom<Row> for DBEvent {
    type Error = postgres::error::Error;

    fn try_from(row: Row) -> Result<Self, Self::Error> {
        Ok(Self {
            id: row.try_get("id")?,
            sequence_number: row.try_get("sequence_number")?,
            event_type: row.try_get("event_type")?,
            entity_type: row.try_get("entity_type")?,
            entity_id: row.try_get("entity_id")?,
            session_id: row.try_get("session_id")?,
            purger_id: row.try_get("purger_id")?,
            created_at: row.try_get("created_at")?,
            purged_at: row.try_get("purged_at")?,
            data: row.try_get("data")?,
        })
    }
}
