# ! [ feature ( prelude_import ) ] # [ prelude_import ] use std :: prelude :: v1 :: * ; # [ macro_use ] extern crate std ; use event_sauce :: CreateEntity ; use event_sauce :: Event ; use event_sauce :: EventData ; use event_sauce :: Persistable ; use event_sauce :: StorageBuilder ; use event_sauce :: UpdateEntity ; use event_sauce_storage_sqlx_pg :: SqlxPgStore ; use sqlx :: PgPool ; use uuid :: Uuid ; struct User { id : Uuid , name : String , email : String , } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_User : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl _serde :: Serialize for User { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "User" , false as usize + 1 + 1 + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "id" , & self . id ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "name" , & self . name ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "email" , & self . email ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_User : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for User { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __field1 , __field2 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , 1u64 => _serde :: export :: Ok ( __Field :: __field1 ) , 2u64 => _serde :: export :: Ok ( __Field :: __field2 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 3" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "id" => _serde :: export :: Ok ( __Field :: __field0 ) , "name" => _serde :: export :: Ok ( __Field :: __field1 ) , "email" => _serde :: export :: Ok ( __Field :: __field2 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"id" => _serde :: export :: Ok ( __Field :: __field0 ) , b"name" => _serde :: export :: Ok ( __Field :: __field1 ) , b"email" => _serde :: export :: Ok ( __Field :: __field2 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < User > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = User ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct User" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < Uuid > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct User with 3 elements" ) ) ; } } ; let __field1 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct User with 3 elements" ) ) ; } } ; let __field2 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 2usize , & "struct User with 3 elements" ) ) ; } } ; _serde :: export :: Ok ( User { id : __field0 , name : __field1 , email : __field2 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < Uuid > = _serde :: export :: None ; let mut __field1 : _serde :: export :: Option < String > = _serde :: export :: None ; let mut __field2 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "id" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < Uuid > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } __Field :: __field1 => { if _serde :: export :: Option :: is_some ( & __field1 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "name" ) ) ; } __field1 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } __Field :: __field2 => { if _serde :: export :: Option :: is_some ( & __field2 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "email" ) ) ; } __field2 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "id" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; let __field1 = match __field1 { _serde :: export :: Some ( __field1 ) => __field1 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "name" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; let __field2 = match __field2 { _serde :: export :: Some ( __field2 ) => __field2 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "email" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( User { id : __field0 , name : __field1 , email : __field2 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "id" , "name" , "email" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "User" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < User > , lifetime : _serde :: export :: PhantomData , } ) } } } ; struct UserCreated { name : String , email : String , } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_UserCreated : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl _serde :: Serialize for UserCreated { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "UserCreated" , false as usize + 1 + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "name" , & self . name ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "email" , & self . email ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_UserCreated : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for UserCreated { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __field1 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , 1u64 => _serde :: export :: Ok ( __Field :: __field1 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 2" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "name" => _serde :: export :: Ok ( __Field :: __field0 ) , "email" => _serde :: export :: Ok ( __Field :: __field1 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"name" => _serde :: export :: Ok ( __Field :: __field0 ) , b"email" => _serde :: export :: Ok ( __Field :: __field1 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < UserCreated > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = UserCreated ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct UserCreated" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct UserCreated with 2 elements" ) ) ; } } ; let __field1 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct UserCreated with 2 elements" ) ) ; } } ; _serde :: export :: Ok ( UserCreated { name : __field0 , email : __field1 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; let mut __field1 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "name" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } __Field :: __field1 => { if _serde :: export :: Option :: is_some ( & __field1 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "email" ) ) ; } __field1 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "name" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; let __field1 = match __field1 { _serde :: export :: Some ( __field1 ) => __field1 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "email" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( UserCreated { name : __field0 , email : __field1 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "name" , "email" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "UserCreated" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < UserCreated > , lifetime : _serde :: export :: PhantomData , } ) } } } ; impl EventData for UserCreated { const EVENT_TYPE : & 'static str = "UserCreated" ; const ENTITY_TYPE : & 'static str = "users" ; } struct UserEmailChanged { email : String , } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_UserEmailChanged : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl _serde :: Serialize for UserEmailChanged { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "UserEmailChanged" , false as usize + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "email" , & self . email ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_UserEmailChanged : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for UserEmailChanged { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 1" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "email" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"email" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < UserEmailChanged > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = UserEmailChanged ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct UserEmailChanged" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct UserEmailChanged with 1 element" ) ) ; } } ; _serde :: export :: Ok ( UserEmailChanged { email : __field0 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "email" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "email" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( UserEmailChanged { email : __field0 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "email" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "UserEmailChanged" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < UserEmailChanged > , lifetime : _serde :: export :: PhantomData , } ) } } } ; impl EventData for UserEmailChanged { const EVENT_TYPE : & 'static str = "UserEmailChanged" ; const ENTITY_TYPE : & 'static str = "users" ; } impl Persistable < SqlxPgStore , User > for User { fn persist < 'life0 , 'async_trait > ( self , store : & 'life0 SqlxPgStore ) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = Result < Self , sqlx :: Error > > + :: core :: marker :: Send + 'async_trait > > where 'life0 : 'async_trait , Self : 'async_trait { # [ allow ( clippy :: missing_docs_in_private_items , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding , ) ] async fn __persist ( _self : User , store : & SqlxPgStore ) -> Result < User , sqlx :: Error > { let new = sqlx :: query ( "insert into users (id, name, email) values ($1, $2, $3)" ) . bind ( _self . id ) . bind ( _self . name ) . bind ( _self . email ) . execute ( & store . pool ) . await ? ; Ok ( new ) } Box :: pin ( __persist :: < > ( self , store ) ) } } impl CreateEntity < UserCreated > for User { fn try_create ( event : Event < UserCreated > ) -> Result < StorageBuilder < User , UserCreated > , & 'static str > { let data = event . data . ok_or ( "Event data must be populated to create User from UserCreated event" ) ? ; let entity = User { id : event . entity_id , name : data . name , email : data . email , } ; Ok ( StorageBuilder :: new ( entity , event ) ) } } impl UpdateEntity < UserEmailChanged > for User { fn try_update ( self , event : Event < UserEmailChanged > ) -> Result < StorageBuilder < User , UserEmailChanged > , & 'static str > { let data = event . data . ok_or ( "Event data must be populated to update User from UserEmailChanged event" ) ? ; let entity = User { email : data . email , .. self } ; Ok ( StorageBuilder :: new ( entity , event ) ) } } extern crate test ; # [ cfg ( test ) ] # [ rustc_test_marker ] pub const create : test :: TestDescAndFn = test :: TestDescAndFn { desc : test :: TestDesc { name : test :: StaticTestName ( "create" ) , ignore : false , allow_fail : false , should_panic : test :: ShouldPanic :: No , test_type : test :: TestType :: IntegrationTest , } , testfn : test :: StaticTestFn ( | | test :: assert_test_result ( create ( ) ) ) , } ; fn create ( ) -> Result < ( ) , ( ) > { async_std :: task :: block_on ( async { { let mut postgres = PgPool :: new ( "postgres://sauce:sauce@localhost/sauce" ) . await . expect ( "Error creating postgres pool" ) ; let store = SqlxPgStore :: new ( postgres ) ; let user = User :: try_create ( UserCreated { name : String :: new ( ) , email : String :: new ( ) , } . into_event ( None ) ) . unwrap ( ) ; let user = user . persist ( & store ) . await . unwrap ( ) ; Ok ( ( ) ) } } ) } # [ main ] pub fn main ( ) -> ( ) { extern crate test ; test :: test_main_static ( & [ & create ] ) }